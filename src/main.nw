

\section{Main Module}

Everything starts at the main module: it parses the command line and
calls functions that do the actual work. Catching and reporting errors
to the user is also the main modules' responsibility. The Main module
has an interface but since [[main]] is called automatically it is not of
much use.

<<main.mli>>=
val main: unit -> unit (* executed automatically *)
@

\subsection{Implementation}

<<main.ml>>=
exception Error of string
exception Usage of string

let error   fmt = Printf.kprintf (fun msg -> raise (Error msg)) fmt
let usage   fmt = Printf.kprintf (fun msg -> raise (Usage msg)) fmt
 
let printf      = Printf.printf
let sprintf     = Printf.sprintf
let version     = "1.0.0"
let (@@) f x    = f x

let this        = Sys.argv.(0)

let synopsis =
    [ "usage: "^this^" [options] [file.annot]" 
    ; ""
    ; "-type line column            lookup type annotation for position"
    ; "-dump                        dump annotations to stdout"
    ; "-n                           suppress newline after last line"
    ; "-r                           include range for annotation"
    ; "-h, -help                    offer minimal help on stdout"
    ; ""
    ; "Version "^version
    ; "Maintainer:      Anil Madhavapedddy http://anil.recoil.org/"
    ; "Author:          Christian Lindig <lindig@gmail.com>"
    ; "Source code available from https://github.com/avsm/ocaml-annot.git"
    ]
    
let help ()    = List.iter print_endline synopsis
@

<<main.ml>>=
module A = Annot.ByPosition
@

I don't know why we need to normalize file paths and we need regular
expression matching and why we need to find a common prefix when looking
for the file.

<<unused.ml>>=
external realpath: string -> string = "unix_realpath"
(** Normalizes a Unix file path, see realpath(3) *)

<<unused.ml>>=
let find file =
  let cwd = realpath (Sys.getcwd ()) in
  let filedir = realpath (Filename.dirname file) in
  let filename = Filename.basename file in
  let file = Filename.concat filedir filename in
  (* Find common prefix between requested file and cwd *)
  match Str.bounded_split (Str.regexp_string cwd) file 1 with 
  |[suffix] ->
    let result = ref None in
    (* Look in cwd+backend+suffix in descending priority *)
    let backends = [ ""; "_build"; "_build/unix-socket";
      "_build/unix-direct"; "_build/node"; "_build/xen" ] in
    List.iter (fun backend ->
      let f = Printf.sprintf "%s/%s/%s" cwd backend suffix in
      if Sys.file_exists f then
        result := Some f;
    ) (List.rev backends);
    (match !result with
    | Some r -> r
    | None   -> error "Can't find %s" file
    )
  |_ -> error "Can't find file %s" file

@ We expect that the file containing the annotations for a source code
position is read from a file whose name is passed on the command line or
read from stdin. Typically the tool is called from within an editor that
knows the source file for which annotations should be consulted but it
might not know where the corresponding annotations file resides. The reason
is that the connection between a source file and the file containing its
annotations isn't obvious.

Traditionally, a source file and its compiler-generated annotation file
lived in the same directory. But build tools like OCamlbuild popularized
the idea to keep compiler-generated files in a separate directory. We want
to provide a little support for this situation by helping to locate an
annotations file.

This tool employs the following heuristic to find a file containing source
code annotations:

1.  If the file name provided to the tool is an absolute path, the tool
    expects this file to contain the annotations. It fails, if the file
    doesn't exist.

2.  If the file name provided to the tool is a relative path, the tool will
    use it in a search heuristic.  The (relative) file name is prepended
    with each element from a search path until it finds a file or the
    search path is exhausted and it fails.

For now, the search path is hard coded here. In the future, we might want
to read it from an environment variable.

<<main.ml>>=
let (//)        = Filename.concat 
let searchpath  = 
    [ "."
    ; "_build"
    ; ".." // "_build"
      (* Those below should not be in here as they are too specific.
         Keeping them for backward compatibility for now *)
    ; "_build" // "unix-socket"
    ; "_build" // "unix-direct"
    ; "_build" // "node"
    ; "_build" // "xen" 
    ]

<<main.ml>>=
let search file searchpath =
    (** return path to file that has been found utilizing a searchpath *)
    assert (Filename.is_relative file);
    let exists path = Sys.file_exists (path // file) in 
    try 
        List.find exists searchpath // file
    with 
        Not_found -> error "Can't find file %s" file

let find (file: string) = 
    if Filename.is_relative file then search file searchpath
    else if Sys.file_exists file then file (* absolute file path *)
    else error "Can't find file %s" file
@

@ Operation [[with_file]] opens a file for reading and passes the file
handle to an action. It takes care of closing the file, even in the case
of errors.

<<main.ml>>=
let with_file file action =
    let ic = open_in file in
    let result = try action ic with exn -> close_in ic; raise exn in  
        close_in ic; result
        
let annotations_from channel = 
    let lexbuf = Lexing.from_channel channel in
    try
        Parser.annotations Scanner.token lexbuf
    with
        Parsing.Parse_error -> 
            error "parse error at offset %d" (Lexing.lexeme_start lexbuf)

@

Options that control the format when emitting annotations.

<<main.ml>>=
type options =
    { mutable newline:  bool    (* emit newline after annotation *)
    ; mutable range:    bool    (* include range in type annotation *)
    }
    
let options: options = (* with defaults *)
    { newline   =   true
    ; range     =   false
    }
@

Read type annotation from channel [[ic]] and report the annotation for a
given [[line]] and [[column]] to stdout. We first build an interval map
and then search it for the given position.

<<main.ml>>=
let int: string -> int = 
    (** Convert string to integer of fail *)
    fun x -> try int_of_string x with Failure _ -> error "not an int: %s" x

let typeannot options line column ic = 
    let line, column = int line, int column in
    let nl           = if options.newline then "\n" else "" in
    let range ((l,c),(l',c')) = match options.range with
        | false -> ""
        | true  -> Printf.sprintf "%d:%d-%d:%d " l c l' c' in 
    let annots = annotations_from ic in
        match A.find annots (line, column) with
        | Some (r,s) -> print_string (range r ^ s ^ nl)
        | None       -> print_string ("no type found" ^ nl)
@    
 
Read annotations from channel [[ic]], build an interval map from it and
dump it to stdout (for debugging).

<<main.ml>>= 
let dump ic = A.dump (fun x -> x) @@ annotations_from ic

let main () =
    let argv    = Array.to_list Sys.argv in
    let args    = List.tl argv in
    let rec parse = function
        | "-h"               :: [] -> help ()
        | "-help"            :: [] -> help ()
        | "-n"               :: args -> options.newline <- false; parse args
        | "-r"               :: args -> options.range   <- true;  parse args
        | ["-type"; line;col;file] -> with_file (find file) 
                                        @@ typeannot options line col 
        | ["-type"; line;col]      -> typeannot options line col stdin
        | ["-dump"; file]          -> with_file (find file) dump
        | ["-dump"]                -> dump stdin
        | x :: _ -> usage "error: illegal command line argument %s" x
        | []     -> usage "error: expected an option"
    in              
        parse args

let () = 
    if !Sys.interactive then 
        () 
    else try main (); exit 0 with
        |   Usage     msg -> prerr_endline msg; exit 1
        |   Error     msg -> prerr_endline msg; exit 1
        |   Sys_error msg -> prerr_endline msg; exit 1
@




